'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var childProcess = require('child_process');

var _require = require('./process'),
    isLinux = _require.isLinux,
    getReport = _require.getReport;

var command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';
var commandOut = '';

var safeCommand = function safeCommand() {
  if (!commandOut) {
    return new Promise(function (resolve) {
      childProcess.exec(command, function (err, out) {
        commandOut = err ? ' ' : out;
        resolve(commandOut);
      });
    });
  }

  return commandOut;
};

var safeCommandSync = function safeCommandSync() {
  if (!commandOut) {
    try {
      commandOut = childProcess.execSync(command, {
        encoding: 'utf8'
      });
    } catch (_err) {
      commandOut = ' ';
    }
  }

  return commandOut;
};
/**
 * A String constant containing the value `glibc`.
 * @type {string}
 * @public
 */


var GLIBC = 'glibc';
/**
 * A String constant containing the value `musl`.
 * @type {string}
 * @public
 */

var MUSL = 'musl';

var isFileMusl = function isFileMusl(f) {
  return f.includes('libc.musl-') || f.includes('ld-musl-');
};

var familyFromReport = function familyFromReport() {
  var report = getReport();

  if (report.header && report.header.glibcVersionRuntime) {
    return GLIBC;
  }

  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return MUSL;
    }
  }

  return null;
};

var familyFromCommand = function familyFromCommand(out) {
  var _out$split = out.split(/[\r\n]+/),
      _out$split2 = _slicedToArray(_out$split, 2),
      getconf = _out$split2[0],
      ldd1 = _out$split2[1];

  if (getconf && getconf.includes(GLIBC)) {
    return GLIBC;
  }

  if (ldd1 && ldd1.includes(MUSL)) {
    return MUSL;
  }

  return null;
};
/**
 * Resolves with the libc family when it can be determined, `null` otherwise.
 * @returns {Promise<?string>}
 */


var family = function family() {
  var family, out;
  return regeneratorRuntime.async(function family$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          family = null;

          if (!isLinux()) {
            _context.next = 8;
            break;
          }

          family = familyFromReport();

          if (family) {
            _context.next = 8;
            break;
          }

          _context.next = 6;
          return regeneratorRuntime.awrap(safeCommand());

        case 6:
          out = _context.sent;
          family = familyFromCommand(out);

        case 8:
          return _context.abrupt("return", family);

        case 9:
        case "end":
          return _context.stop();
      }
    }
  });
};
/**
 * Returns the libc family when it can be determined, `null` otherwise.
 * @returns {?string}
 */


var familySync = function familySync() {
  var family = null;

  if (isLinux()) {
    family = familyFromReport();

    if (!family) {
      var out = safeCommandSync();
      family = familyFromCommand(out);
    }
  }

  return family;
};
/**
 * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.
 * @returns {Promise<boolean>}
 */


var isNonGlibcLinux = function isNonGlibcLinux() {
  return regeneratorRuntime.async(function isNonGlibcLinux$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.t0 = isLinux();

          if (!_context2.t0) {
            _context2.next = 7;
            break;
          }

          _context2.next = 4;
          return regeneratorRuntime.awrap(family());

        case 4:
          _context2.t1 = _context2.sent;
          _context2.t2 = GLIBC;
          _context2.t0 = _context2.t1 !== _context2.t2;

        case 7:
          return _context2.abrupt("return", _context2.t0);

        case 8:
        case "end":
          return _context2.stop();
      }
    }
  });
};
/**
 * Returns `true` only when the platform is Linux and the libc family is not `glibc`.
 * @returns {boolean}
 */


var isNonGlibcLinuxSync = function isNonGlibcLinuxSync() {
  return isLinux() && familySync() !== GLIBC;
};

var versionFromReport = function versionFromReport() {
  var report = getReport();

  if (report.header && report.header.glibcVersionRuntime) {
    return report.header.glibcVersionRuntime;
  }

  return null;
};

var versionSuffix = function versionSuffix(s) {
  return s.trim().split(/\s+/)[1];
};

var versionFromCommand = function versionFromCommand(out) {
  var _out$split3 = out.split(/[\r\n]+/),
      _out$split4 = _slicedToArray(_out$split3, 3),
      getconf = _out$split4[0],
      ldd1 = _out$split4[1],
      ldd2 = _out$split4[2];

  if (getconf && getconf.includes(GLIBC)) {
    return versionSuffix(getconf);
  }

  if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
    return versionSuffix(ldd2);
  }

  return null;
};
/**
 * Resolves with the libc version when it can be determined, `null` otherwise.
 * @returns {Promise<?string>}
 */


var version = function version() {
  var version, out;
  return regeneratorRuntime.async(function version$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          version = null;

          if (!isLinux()) {
            _context3.next = 8;
            break;
          }

          version = versionFromReport();

          if (version) {
            _context3.next = 8;
            break;
          }

          _context3.next = 6;
          return regeneratorRuntime.awrap(safeCommand());

        case 6:
          out = _context3.sent;
          version = versionFromCommand(out);

        case 8:
          return _context3.abrupt("return", version);

        case 9:
        case "end":
          return _context3.stop();
      }
    }
  });
};
/**
 * Returns the libc version when it can be determined, `null` otherwise.
 * @returns {?string}
 */


var versionSync = function versionSync() {
  var version = null;

  if (isLinux()) {
    version = versionFromReport();

    if (!version) {
      var out = safeCommandSync();
      version = versionFromCommand(out);
    }
  }

  return version;
};

module.exports = {
  GLIBC: GLIBC,
  MUSL: MUSL,
  family: family,
  familySync: familySync,
  isNonGlibcLinux: isNonGlibcLinux,
  isNonGlibcLinuxSync: isNonGlibcLinuxSync,
  version: version,
  versionSync: versionSync
};