"use strict";

var bcrypt = require('../bcrypt');

var EXPECTED = 2500; //number of times to iterate these tests.)

test('salt_length', function () {
  expect.assertions(EXPECTED);
  return Promise.all(Array.from({
    length: EXPECTED
  }, function () {
    return bcrypt.genSalt(10).then(function (salt) {
      return expect(salt).toHaveLength(29);
    });
  }));
});
test('test_hash_length', function () {
  expect.assertions(EXPECTED);
  var SALT = '$2a$04$TnjywYklQbbZjdjBgBoA4e';
  return Promise.all(Array.from({
    length: EXPECTED
  }, function () {
    return bcrypt.hash('test', SALT).then(function (hash) {
      return expect(hash).toHaveLength(60);
    });
  }));
});
test('test_compare', function () {
  expect.assertions(EXPECTED);
  var HASH = '$2a$04$TnjywYklQbbZjdjBgBoA4e9G7RJt9blgMgsCvUvus4Iv4TENB5nHy';
  return Promise.all(Array.from({
    length: EXPECTED
  }, function () {
    return bcrypt.compare('test', HASH).then(function (match) {
      return expect(match).toEqual(true);
    });
  }));
});
test('test_hash_and_compare', function () {
  expect.assertions(EXPECTED * 3);
  var salt = bcrypt.genSaltSync(4);
  return Promise.all(Array.from({
    length: EXPECTED
  }, function () {
    var password = 'secret' + Math.random();
    return bcrypt.hash(password, salt).then(function (hash) {
      expect(hash).toHaveLength(60);
      var goodCompare = bcrypt.compare(password, hash).then(function (res) {
        return expect(res).toEqual(true);
      });
      var badCompare = bcrypt.compare('bad' + password, hash).then(function (res) {
        return expect(res).toEqual(false);
      });
      return Promise.all([goodCompare, badCompare]);
    });
  }));
}, 10000);