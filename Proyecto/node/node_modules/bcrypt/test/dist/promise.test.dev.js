"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var bcrypt = require('../bcrypt');

var promises = require('../promises');

test('salt_returns_promise_on_no_args', function () {
  // make sure test passes with non-native implementations such as bluebird
  // http://stackoverflow.com/questions/27746304/how-do-i-tell-if-an-object-is-a-promise
  expect(_typeof(bcrypt.genSalt().then)).toEqual('function');
});
test('salt_returns_promise_on_null_callback', function () {
  expect(_typeof(bcrypt.genSalt(13, null, null).then)).toEqual('function');
});
test('salt_length', function () {
  return expect(bcrypt.genSalt(10)).resolves.toHaveLength(29);
});
test('salt_rounds_is_string_number', function () {
  return expect(bcrypt.genSalt('10')).rejects.toThrow('rounds must be a number');
});
test('salt_rounds_is_string_non_number', function () {
  return expect(bcrypt.genSalt('b')).rejects.toThrow('rounds must be a number');
});
test('hash_returns_promise_on_null_callback', function () {
  expect(_typeof(bcrypt.hash('password', 10, null).then)).toStrictEqual('function');
});
test('hash', function () {
  return expect(bcrypt.genSalt(10).then(function (salt) {
    return bcrypt.hash('password', salt);
  })).resolves.toBeDefined();
});
test('hash_rounds', function () {
  return bcrypt.hash('bacon', 8).then(function (hash) {
    expect(bcrypt.getRounds(hash)).toStrictEqual(8);
  });
});
test('hash_empty_strings', function () {
  expect.assertions(2);
  return Promise.all([expect(bcrypt.genSalt(10).then(function (salt) {
    return bcrypt.hash('', salt);
  })).resolves.toBeDefined(), expect(bcrypt.hash('', '')).rejects.toThrow('')]);
});
test('hash_no_params', function () {
  expect.assertions(1);
  return expect(bcrypt.hash()).rejects.toThrow('data and salt arguments required');
});
test('hash_one_param', function () {
  return expect(bcrypt.hash('password')).rejects.toThrow('data and salt arguments required');
});
test('hash_salt_validity', function () {
  expect.assertions(2);
  return Promise.all([expect(bcrypt.hash('password', '$2a$10$somesaltyvaluertsetrse')).resolves.toBeDefined(), expect(bcrypt.hash('password', 'some$value')).rejects.toThrow("Invalid salt. Salt must be in the form of: $Vers$log2(NumRounds)$saltvalue")]);
});
test('verify_salt', function () {
  expect.assertions(2);
  return bcrypt.genSalt(10).then(function (result) {
    var _result$split = result.split('$'),
        _result$split2 = _slicedToArray(_result$split, 3),
        _ = _result$split2[0],
        version = _result$split2[1],
        salt = _result$split2[2];

    expect(version).toEqual('2b');
    expect(salt).toEqual('10');
  });
});
test('verify_salt_min_rounds', function () {
  expect.assertions(2);
  return bcrypt.genSalt(1).then(function (value) {
    var _value$split = value.split('$'),
        _value$split2 = _slicedToArray(_value$split, 3),
        _ = _value$split2[0],
        version = _value$split2[1],
        rounds = _value$split2[2];

    expect(version).toEqual('2b');
    expect(rounds).toEqual('04');
  });
});
test('verify_salt_max_rounds', function () {
  expect.assertions(2);
  return bcrypt.genSalt(100).then(function (value) {
    var _value$split3 = value.split('$'),
        _value$split4 = _slicedToArray(_value$split3, 3),
        _ = _value$split4[0],
        version = _value$split4[1],
        rounds = _value$split4[2];

    expect(version).toEqual('2b');
    expect(rounds).toEqual('31');
  });
});
test('hash_compare_returns_promise_on_null_callback', function () {
  expect(_typeof(bcrypt.compare('password', 'something', null).then)).toStrictEqual('function');
});
test('hash_compare', function () {
  expect.assertions(3);
  return bcrypt.genSalt(10).then(function (salt) {
    expect(salt).toHaveLength(29);
    return bcrypt.hash("test", salt);
  }).then(function (hash) {
    return Promise.all([expect(bcrypt.compare("test", hash)).resolves.toEqual(true), expect(bcrypt.compare("blah", hash)).resolves.toEqual(false)]);
  });
});
test('hash_compare_empty_strings', function () {
  expect.assertions(2);
  var hash = bcrypt.hashSync("test", bcrypt.genSaltSync(10));
  return Promise.all([expect(bcrypt.compare("", hash)).resolves.toEqual(false), expect(bcrypt.compare("", "")).resolves.toEqual(false)]);
});
test('hash_compare_invalid_strings', function () {
  var fullString = 'envy1362987212538';
  var hash = '$2a$10$XOPbrlUPQdwdJUpSrIF6X.LbE14qsMmKGhM1A8W9iqaG3vv1BD7WC';
  var wut = ':';
  return Promise.all([expect(bcrypt.compare(fullString, hash)).resolves.toEqual(true), expect(bcrypt.compare(fullString, wut)).resolves.toEqual(false)]);
});
test('hash_compare_no_params', function () {
  expect.assertions(1);
  return expect(bcrypt.compare()).rejects.toThrow('data and hash arguments required');
});
test('hash_compare_one_param', function () {
  expect.assertions(1);
  return expect(bcrypt.compare('password')).rejects.toThrow('data and hash arguments required');
});
test('change_promise_impl_reject', function () {
  promises.use({
    reject: function reject() {
      return 'mock';
    }
  });
  expect(promises.reject()).toEqual('mock'); // need to reset the promise implementation because of require cache

  promises.use(global.Promise);
});
test('change_promise_impl_promise', function () {
  promises.use({
    reject: function reject(err) {
      expect(err.message).toEqual('fn must be a function');
      return 'mock';
    }
  });
  expect(promises.promise('', '', '')).toEqual('mock'); // need to reset the promise implementation because of require cache

  promises.use(global.Promise);
});