"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var bcrypt = require('../bcrypt');

test('salt_length', function (done) {
  expect.assertions(1);
  bcrypt.genSalt(10, function (err, salt) {
    expect(salt).toHaveLength(29);
    done();
  });
});
test('salt_only_cb', function () {
  expect.assertions(1);
  expect(function () {
    bcrypt.genSalt(function (err, salt) {});
  }).not.toThrow();
});
test('salt_rounds_is_string_number', function (done) {
  expect.assertions(2);
  bcrypt.genSalt('10', void 0, function (err, salt) {
    expect(err instanceof Error).toBe(true);
    expect(err.message).toBe('rounds must be a number');
    done();
  });
});
test('salt_rounds_is_string_non_number', function (done) {
  expect.assertions(2);
  bcrypt.genSalt('z', function (err, salt) {
    expect(err instanceof Error).toBe(true);
    expect(err.message).toBe('rounds must be a number');
    done();
  });
});
test('salt_minor', function (done) {
  expect.assertions(3);
  bcrypt.genSalt(10, 'a', function (err, value) {
    expect(value).toHaveLength(29);

    var _value$split = value.split('$'),
        _value$split2 = _slicedToArray(_value$split, 3),
        _ = _value$split2[0],
        minor = _value$split2[1],
        salt = _value$split2[2];

    expect(minor).toEqual('2a');
    expect(salt).toEqual('10');
    done();
  });
});
test('salt_minor_b', function (done) {
  expect.assertions(3);
  bcrypt.genSalt(10, 'b', function (err, value) {
    expect(value).toHaveLength(29);

    var _value$split3 = value.split('$'),
        _value$split4 = _slicedToArray(_value$split3, 3),
        _ = _value$split4[0],
        minor = _value$split4[1],
        salt = _value$split4[2];

    expect(minor).toEqual('2b');
    expect(salt).toEqual('10');
    done();
  });
});
test('hash', function (done) {
  expect.assertions(2);
  bcrypt.genSalt(10, function (err, salt) {
    bcrypt.hash('password', salt, function (err, res) {
      expect(res).toBeDefined();
      expect(err).toBeUndefined();
      done();
    });
  });
});
test('hash_rounds', function (done) {
  expect.assertions(1);
  bcrypt.hash('bacon', 8, function (err, hash) {
    expect(bcrypt.getRounds(hash)).toEqual(8);
    done();
  });
});
test('hash_empty_strings', function (done) {
  expect.assertions(1);
  bcrypt.genSalt(10, function (err, salt) {
    bcrypt.hash('', salt, function (err, res) {
      expect(res).toBeDefined();
      done();
    });
  });
});
test('hash_fails_with_empty_salt', function (done) {
  expect.assertions(1);
  bcrypt.hash('', '', function (err, res) {
    expect(err.message).toBe('Invalid salt. Salt must be in the form of: $Vers$log2(NumRounds)$saltvalue');
    done();
  });
});
test('hash_no_params', function (done) {
  expect.assertions(1);
  bcrypt.hash(function (err, hash) {
    expect(err.message).toBe('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
    done();
  });
});
test('hash_one_param', function (done) {
  expect.assertions(1);
  bcrypt.hash('password', function (err, hash) {
    expect(err.message).toBe('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
    done();
  });
});
test('hash_salt_validity', function (done) {
  expect.assertions(2);
  bcrypt.hash('password', '$2a$10$somesaltyvaluertsetrse', function (err, enc) {
    expect(err).toBeUndefined();
    bcrypt.hash('password', 'some$value', function (err, enc) {
      expect(err.message).toBe("Invalid salt. Salt must be in the form of: $Vers$log2(NumRounds)$saltvalue");
      done();
    });
  });
});
test('verify_salt', function (done) {
  expect.assertions(2);
  bcrypt.genSalt(10, function (err, value) {
    var _value$split5 = value.split('$'),
        _value$split6 = _slicedToArray(_value$split5, 3),
        _ = _value$split6[0],
        version = _value$split6[1],
        rounds = _value$split6[2];

    expect(version).toEqual('2b');
    expect(rounds).toEqual('10');
    done();
  });
});
test('verify_salt_min_rounds', function (done) {
  expect.assertions(2);
  bcrypt.genSalt(1, function (err, value) {
    var _value$split7 = value.split('$'),
        _value$split8 = _slicedToArray(_value$split7, 3),
        _ = _value$split8[0],
        version = _value$split8[1],
        rounds = _value$split8[2];

    expect(version).toEqual('2b');
    expect(rounds).toEqual('04');
    done();
  });
});
test('verify_salt_max_rounds', function (done) {
  expect.assertions(2);
  bcrypt.genSalt(100, function (err, value) {
    var _value$split9 = value.split('$'),
        _value$split10 = _slicedToArray(_value$split9, 3),
        _ = _value$split10[0],
        version = _value$split10[1],
        rounds = _value$split10[2];

    expect(version).toEqual('2b');
    expect(rounds).toEqual('31');
    done();
  });
});
test('hash_compare', function (done) {
  expect.assertions(2);
  bcrypt.genSalt(10, function (err, salt) {
    bcrypt.hash("test", salt, function (err, hash) {
      bcrypt.compare("test", hash, function (err, res) {
        expect(hash).toBeDefined();
        bcrypt.compare("blah", hash, function (err, res) {
          expect(res).toBe(false);
          done();
        });
      });
    });
  });
});
test('hash_compare_empty_strings', function (done) {
  expect.assertions(2);
  var hash = bcrypt.hashSync("test", bcrypt.genSaltSync(10));
  bcrypt.compare("", hash, function (err, res) {
    expect(res).toEqual(false);
    bcrypt.compare("", "", function (err, res) {
      expect(res).toEqual(false);
      done();
    });
  });
});
test('hash_compare_invalid_strings', function (done) {
  expect.assertions(2);
  var fullString = 'envy1362987212538';
  var hash = '$2a$10$XOPbrlUPQdwdJUpSrIF6X.LbE14qsMmKGhM1A8W9iqaG3vv1BD7WC';
  var wut = ':';
  bcrypt.compare(fullString, hash, function (err, res) {
    expect(res).toBe(true);
    bcrypt.compare(fullString, wut, function (err, res) {
      expect(res).toBe(false);
      done();
    });
  });
});
test('compare_no_params', function (done) {
  expect.assertions(1);
  bcrypt.compare(function (err, hash) {
    expect(err.message).toBe('data and hash arguments required');
    done();
  });
});
test('hash_compare_one_param', function (done) {
  expect.assertions(1);
  bcrypt.compare('password', function (err, hash) {
    expect(err.message).toBe('data and hash arguments required');
    done();
  });
});