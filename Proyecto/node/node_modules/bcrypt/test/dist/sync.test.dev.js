"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var bcrypt = require('../bcrypt');

test('salt_length', function () {
  var salt = bcrypt.genSaltSync(13);
  expect(salt).toHaveLength(29);

  var _salt$split = salt.split('$'),
      _salt$split2 = _slicedToArray(_salt$split, 3),
      _ = _salt$split2[0],
      version = _salt$split2[1],
      rounds = _salt$split2[2];

  expect(version).toStrictEqual('2b');
  expect(rounds).toStrictEqual('13');
});
test('salt_no_params', function () {
  var salt = bcrypt.genSaltSync();

  var _salt$split3 = salt.split('$'),
      _salt$split4 = _slicedToArray(_salt$split3, 3),
      _ = _salt$split4[0],
      version = _salt$split4[1],
      rounds = _salt$split4[2];

  expect(version).toStrictEqual('2b');
  expect(rounds).toStrictEqual('10');
});
test('salt_rounds_is_string_number', function () {
  expect(function () {
    return bcrypt.genSaltSync('10');
  }).toThrowError('rounds must be a number');
});
test('salt_rounds_is_NaN', function () {
  expect(function () {
    return bcrypt.genSaltSync('b');
  }).toThrowError("rounds must be a number");
});
test('salt_minor_a', function () {
  var salt = bcrypt.genSaltSync(10, 'a');

  var _salt$split5 = salt.split('$'),
      _salt$split6 = _slicedToArray(_salt$split5, 3),
      _ = _salt$split6[0],
      version = _salt$split6[1],
      rounds = _salt$split6[2];

  expect(version).toStrictEqual('2a');
  expect(rounds).toStrictEqual('10');
});
test('salt_minor_b', function () {
  var salt = bcrypt.genSaltSync(10, 'b');

  var _salt$split7 = salt.split('$'),
      _salt$split8 = _slicedToArray(_salt$split7, 3),
      _ = _salt$split8[0],
      version = _salt$split8[1],
      rounds = _salt$split8[2];

  expect(version).toStrictEqual('2b');
  expect(rounds).toStrictEqual('10');
});
test('hash', function () {
  expect(function () {
    return bcrypt.hashSync('password', bcrypt.genSaltSync(10));
  }).not.toThrow();
});
test('hash_rounds', function () {
  var hash = bcrypt.hashSync('password', 8);
  expect(bcrypt.getRounds(hash)).toStrictEqual(8);
});
test('hash_empty_string', function () {
  expect(function () {
    return bcrypt.hashSync('', bcrypt.genSaltSync(10));
  }).not.toThrow();
  expect(function () {
    return bcrypt.hashSync('password', '');
  }).toThrowError('Invalid salt. Salt must be in the form of: $Vers$log2(NumRounds)$saltvalue');
  expect(function () {
    return bcrypt.hashSync('', '');
  }).toThrowError('Invalid salt. Salt must be in the form of: $Vers$log2(NumRounds)$saltvalue');
});
test('hash_pw_no_params', function () {
  expect(function () {
    return bcrypt.hashSync();
  }).toThrow('data and salt arguments required');
});
test('hash_pw_one_param', function () {
  expect(function () {
    return bcrypt.hashSync('password');
  }).toThrow('data and salt arguments required');
});
test('hash_pw_not_hash_str', function () {
  expect(function () {
    return bcrypt.hashSync('password', {});
  }).toThrow("data must be a string or Buffer and salt must either be a salt string or a number of rounds");
});
test('hash_salt_validity', function () {
  expect(2);
  expect(bcrypt.hashSync('password', '$2a$10$somesaltyvaluertsetrse')).toBeDefined();
  expect(function () {
    return bcrypt.hashSync('password', 'some$value');
  }).toThrow('Invalid salt. Salt must be in the form of: $Vers$log2(NumRounds)$saltvalue');
});
test('verify_salt', function () {
  var salt = bcrypt.genSaltSync(10);
  var split_salt = salt.split('$');
  expect(split_salt[1]).toStrictEqual('2b');
  expect(split_salt[2]).toStrictEqual('10');
});
test('verify_salt_min_rounds', function () {
  var salt = bcrypt.genSaltSync(1);
  var split_salt = salt.split('$');
  expect(split_salt[1]).toStrictEqual('2b');
  expect(split_salt[2]).toStrictEqual('04');
});
test('verify_salt_max_rounds', function () {
  var salt = bcrypt.genSaltSync(100);
  var split_salt = salt.split('$');
  expect(split_salt[1]).toStrictEqual('2b');
  expect(split_salt[2]).toStrictEqual('31');
});
test('hash_compare', function () {
  var salt = bcrypt.genSaltSync(10);
  expect(29).toStrictEqual(salt.length);
  var hash = bcrypt.hashSync("test", salt);
  expect(bcrypt.compareSync("test", hash)).toBeDefined();
  expect(!bcrypt.compareSync("blah", hash)).toBeDefined();
});
test('hash_compare_empty_strings', function () {
  expect(!bcrypt.compareSync("", "password")).toBeDefined();
  expect(!bcrypt.compareSync("", "")).toBeDefined();
  expect(!bcrypt.compareSync("password", "")).toBeDefined();
});
test('hash_compare_invalid_strings', function () {
  var fullString = 'envy1362987212538';
  var hash = '$2a$10$XOPbrlUPQdwdJUpSrIF6X.LbE14qsMmKGhM1A8W9iqaG3vv1BD7WC';
  var wut = ':';
  expect(bcrypt.compareSync(fullString, hash)).toBe(true);
  expect(bcrypt.compareSync(fullString, wut)).toBe(false);
});
test('getRounds', function () {
  var hash = bcrypt.hashSync("test", bcrypt.genSaltSync(9));
  expect(9).toStrictEqual(bcrypt.getRounds(hash));
});
test('getRounds', function () {
  var hash = bcrypt.hashSync("test", bcrypt.genSaltSync(9));
  expect(9).toStrictEqual(bcrypt.getRounds(hash));
  expect(function () {
    return bcrypt.getRounds('');
  }).toThrow("invalid hash provided");
});